---
layout: post
title: "【转载】session 机制详解以及 session 的相关应用"
date: 2016-07-20 11:07
tags: cookie session
category: web
author: Aidan
---

session 是 web 开发里一个重要的概念，在大多数 web 应用里 session 都是被当做现成的东西，拿来就直接用，但是一些复杂的 web 应用里能拿来用的 session 已经满足不了实际的需求，当碰到这样的情况时候我们需要更加深入的理解 session 的机制，本文将梳理下 session 的相关知识，为设计可替代 web 容器自带的 session 机制打个基础。

# 1 session 的概念

在计算机专业术语里：session 是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册入系统到注销系统之间所经过的时间以及如果需要的话，可能还有一定操作空间。
 
具体到 web 应用里的 session ，大家都做过 web 开发，这里我就先不提出 web 里 session 的定义，先和大伙讲下和 session 相关的技术背景。
 
早期的 web 应用或者说早期的网站都是一种处理静态资源的网站，功能主要是查看文档，看看图片，而现在的 web 应用和早期的差别已经很大，互联网的网站更准确的定义应该是`互联网软件即网站就是软件`，网站所代表的软件和早期软件的定义是不一样的，早期的软件都是在单机环境下运行，而互联网的普及让`软件和网络技术融合在一起`，这就要求网站所代表的软件应该要有一个`对事务处理的记忆功能`，事务处理的记忆功能就是我们常说的`要有状态`。而实现web应用技术的核心 http 协议是一个无状态的协议，http 这种设计也许是历史遗留问题，也许无状态的 http 是最简单也是最有效的通讯方式，但是当网站成为软件后，状态的保持就是一个很重要的功能。
因此在 web 应用开发里就出现了保持 http 链接状态的技术：一个是 cookie 技术，另一种是 session 技术。
 
cookie 技术是客户端的解决方案（当然随着 html5 的出现，比 cookie 更为强劲和安全的技术出现了，但是鉴于 html5 的普及度不够，就不做本文讨论的内容了），Cookie 就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持 Cookie 的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在 HTTP 响应体（Response Body）中的，而是存放于 HTTP 响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于 Windows 操作系统而言，我们可以从： [系统盘]:`\Documents and Settings\[用户名]\Cookies`目录中找到存储的 Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的 Cookie 再次发回至服务器。而这次，Cookie 信息则存放在 HTTP 请求头（Request Header）了。有了 Cookie 这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的 Cookie 得到客户端特有的信息，从而动态生成与该客户端相对应的内容。通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过 Cookie 实现的。
 
session 技术则是服务端的解决方案，它是通过服务器来保持状态的。由于 Session 这个词汇包含的语义很多，因此需要在这里明确一下 Session 的含义。首先，我们通常都会把 Session 翻译成`会话`，因此我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个 Session。从这个语义出发，我们会提到 Session 持续的时间，会提到在 Session 过程中进行了什么操作等等；其次，Session 指的是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。从这个语义出发，我们则会提到往 Session 中存放什么内容，如何根据键值从 Session 中获取匹配的内容等。要使用 Session，第一步当然是创建 Session 了。那么 Session 在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建 Session 的方法，而在 Java 中是通过调用 HttpServletRequest 的 getSession 方法（使用 true 作为参数）创建的。在创建了 Session 的同时，服务器会为该 Session 生成唯一的 Session id ，而这个 Session id 在随后的请求中会被用来重新获得已经创建的 Session；在 Session 被创建之后，就可以调用 Session 相关的方法往 Session 中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有 Session id ；当客户端再次发送请求的时候，会将这个 Session id 带上，服务器接受到请求之后就会依据 Session id 找到相应的 Session，从而再次使用之。正式这样一个过程，用户的状态也就得以保持了。
 
由此我们可以得出，`session 是解决 http 协议无状态问题的服务端解决方案`，它能让客户端和服务端一系列交互动作变成一个完整的事务，能使网站变成一个真正意义上的软件。

# 2 cookie与session的关系

cookie 和 session 的方案虽然分别属于客户端和服务端，但是服务端的 session 的实现对客户端的 cookie 有依赖关系的，上面我讲到服务端执行 session 机制时候会生成 session 的 id 值，这个 id 值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个 id 值在客户端会保存下来，保存的容器就是 cookie ，因此当我们完全禁掉浏览器的 cookie 的时候，服务端的 session 也会不能正常使用（注意：有些资料说 ASP 解决这个问题，当浏览器的 cookie 被禁掉，服务端的 session 任然可以正常使用，ASP 我没试验过，但是对于网络上很多用 php 和 jsp 编写的网站，我发现禁掉 cookie，网站的 session 都无法正常的访问）

# 3 java 中 session 实现的原理

请阅读原文。

# 4 在实际运用中session所带来的问题

由上面所描述的 session 实现机制，我们会发现，为了弥补 http 协议的无状态的特点，服务端会占用一定的内存和 cpu 用来存储和处理 session 计算的开销，这也就是 tomcat 这个的 web 容器的并发连接那么低（ tomcat 官方文档里默认的连接数是 200）原因之一。因此很多 java 语言编写的网站，在生产环境里 web 容器之前会加一个静态资源服务器，例如： apache 服务器或 nginx 服务器，静态资源服务器没有解决 http 无状态问题的功能，因此部署静态资源的服务器也就不会让出内存或 cpu 计算资源专门去处理像 session 这样的功能，这些内存和 cpu 资源可以更有效的处理每个 http 请求，因此静态资源服务器的并发连接数更高，所以我们可以让那些没有状态保持要求的请求直接在静态服务器里处理，而要进行状态保持的请求则在 java 的 web 容器里进行处理，这样能更好的提升网站的效率。
 
当下的互联网网站为了提高网站安全性和并发量，服务端的部署的服务器的数量往往是大于或等于两台，多台服务器对外提供的服务是等价的，但是不同的服务器上面肯定会有不同的 web 容器，由上面的讲述我们知道 session 的实现机制都是 web 容器里内部机制，这就导致一个 web 容器里所生成的 session 的 id 值是不同的，因此当一个请求到了 A 服务器，浏览器得到响应后，客户端存下的是 A 服务器上所生成的 session 的 id，当在另一个请求分发到了 B 服务器，B 服务器上的 web 容器是不能识别这个 session 的 id 值，更不会有这个 sessionID 所对应记录下来的信息，这个时候就需要两个不同 web 容器之间进行 session 的同步。`Tomcat 容器有一个官方的解决方案就是使用 apache + tomcat + mod_jk 方案，当一个 web 容器里 session 的信息发生变化后，该 web 容器会向另一个 web 容器进行广播，另一个 web 收到广播后将 session 信息同步到自己的容器里，这个过程是十分消耗系统资源，当访问量增加会严重影响到网站的效率和稳定性。`
 
我现在所做的网站里有一个解决方案，当用户请求网站的时候会先将请求发送给硬件的`负载均衡设备`，该设备可以截获客户端发送过来的 session 的 id 值，然后我们根据这个 id 值找到产生这个 session 的服务器，将请求直接发送给这台服务器。这种解决方案看起来解决了 session 共享问题，其实结果是将集群系统最终变回了单点系统，如果处理请求的 web 容器挂掉了，那么用户的相关会话操作也就废掉了。此外，这种做法也`干扰了负载均衡服务器的负载均衡的计算，让请求的分发并不是公平的`。
 
一般大型互联公司的网站都是有一个个独立的频道所组成的，例如我们常用的百度，会有百度搜索，百度音乐，百度百科等等，我相信他们不会把这些不同频道都给一个开发团队完成，应该每个频道都是一个独立开发团队，因为每个频道的应用的都是独立的 web 应用，那么就存在一个`跨站点的 session 同步`的问题，跨站点的登录可以使用`单点登录的（SSO）`（关于 SSO 可以查看我的另一篇博客：[【转载】单点登录（SSO）简介](/archives/single-sign-on)）的解决方案，但是不管什么解决方案，跨站点的 session 共享任然是逃避不了的问题。

# 5 解决session相关问题的技术方案

由上所述，session 一共有两个问题需要解决：

- （1）session 的存储应该独立于 web 容器，也要独立于部署 web 容器的服务器；
- （2）如何进行高效的 session 同步。

在讲到解决这些问题之前，我们首先要考虑下 session 如何存储才是高效，是存在内存、文件还是数据库了？文件和数据库的存储方式都是将 session 的数据固化到硬盘上，操作硬盘的方式就是 IO，IO 操作的效率是远远低于操作内存的数据，因此文件和数据库存储方式是不可取的，所以将 session 数据存储到内存是最佳的选择。因此最好的解决方案就是使用分布式缓存技术，例如：memcached和redis，将 session 信息的存储独立出来也是解决 session 同步问题的方法。
Tomcat 的 session 同步也有使用 memcache 的解决方案，大家可以参加下面的文章：

[http://blog.sina.com.cn/s/blog_5376c71901017bqx.html](http://blog.sina.com.cn/s/blog_5376c71901017bqx.html)

但是该方案只是解决了同步问题，session 机制任然和 web 容器紧耦合，我们需要一个高效、可扩展的解决方案，那么我们就应该不是简单的把 session 独立出来存储而是设计一个完全独立的 session 机制，它既能给每个 web 应用提供 session 的功能又可以实现 session 同步，下面是一篇用 zookeeper 实现的分布式 session 方案：

[http://www.open-open.com/lib/view/open1378556537303.html](http://www.open-open.com/lib/view/open1378556537303.html)
 
好了写完了，今天只是简单剖析下 session 机制，以后有机会我拿出一套最好的独立 session 设计机制方案来的。

>原文：
>
>[夏天的森林：session机制详解以及session的相关应用](http://www.cnblogs.com/yupeng/archive/2012/05/24/2517317.html)